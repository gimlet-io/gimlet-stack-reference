---
name: Bootstrap curated Kubernetes stacks!
description: |
  Logging, metrics, ingress and more - all delivered with gitops.

categories:
  - name: "‚òÅÔ∏è Cloud Provider"
    id: cloud
  - name: "üóÇÔ∏è Registry"
    id: registry
  - name: "‚¨ÖÔ∏èIngress"
    id: ingress
  - name: "üìë Logging"
    id: logging
  - name: "üîÑ Autoscaling"
    id: autoscaling
  - name: "üî¢ Metrics"
    id: metrics
  - name: "üîê Secrets"
    id: secrets
  - name: "üîç Tracing"
    id: tracing
  - name: "üìã Policy"
    id: policy
  - name: "‚öôÔ∏è Gimlet"
    id: gimlet
  - name: "üñ•Ô∏è System"
    id: system
components:
  - name: K3s / K3d / Rancher Desktop
    variable: k3s
    category: cloud
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/k3s.svg
    description: "Enable k3s defaults to better integrate with locally running K3s, K3d and Rancher Desktop"
    onePager: |-
      Enable k3s defaults to better integrate with locally running K3s, K3d and Rancher Desktop
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#k3s",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "usingBuiltInTraefikIngress": {
            "$id": "#/properties/usingBuiltInTraefikIngress",
            "type": "boolean",
            "title": "Use the Traefik Ingress",
            "default": true
          }
        },
        "dependencies": {
          "usingBuiltInTraefikIngress": {
            "oneOf": [
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#k3s"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: CIVO
    variable: civo
    category: cloud
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/civo.svg
    description: "Enable CIVO Cloud defaults to better integrate into the CIVO landscape"
    onePager: |-
      Enable CIVO Cloud defaults to better integrate into the CIVO landscape
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#civo",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "usingBuiltInTraefikIngress": {
            "$id": "#/properties/usingBuiltInTraefikIngress",
            "type": "boolean",
            "title": "Use the Traefik Ingress from the CIVO marketplace"
          }
        },
        "dependencies": {
          "usingBuiltInTraefikIngress": {
            "oneOf": [
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#civo"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Nginx
    variable: nginx
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/nginx.png
    description: "An Nginx proxy server that routes traffic to your applications based on the host name or path."
    onePager: |-
      ### What do you get with Nginx?

      An Nginx proxy server that routes traffic to your applications based on the host name or path.

      ### How to verify the deployment?

      ```
      $ kubectl get pods,services --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      nginx-nginx-ingress-default-backend-6d96c457f6-hfkn8   1/1     Running   0          114s
      nginx-nginx-ingress-controller-6874d7c7f-l7dzc         1/1     Running   0          114s

      NAME                                          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
      service/nginx-nginx-ingress-controller        LoadBalancer   10.43.199.76    1.2.3.4       80:30377/TCP,443:31126/TCP   114s
      service/nginx-nginx-ingress-default-backend   ClusterIP      10.43.176.181   <none>        80/TCP                       114s
      ```

      ### Pointing a DNS entry to the ingress IP address

      To point a DNS entry to the ingress controller's IP address, let's find the IP first.
            
      ```
      $ kubectl get services --namespace infrastructure

      NAME                                          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
      service/nginx-nginx-ingress-controller        LoadBalancer   10.43.199.76    1.2.3.4       80:30377/TCP,443:31126/TCP   114s
      ```

      **Using a real Kubernetes cluster** the EXTERNAL-IP field is set within a couple of minutes by your cloud provider.

      Once the EXTERNAL-IP is visible, point a wildcard DNS entry `*.yourdomain.com` to that address.

      **Using a local Kubernetes cluster like k3s/k3d or Rancher / Docker Desktop / Minikube / kind** testing the ingress requires a few steps.

      First, port forward the nginx controller to your laptop with the `kubectl port-forward -n infrastructure svc/ingress-nginx-controller 8080:80` command.
      This will make the ingress controller reachable on the `127.0.0.1` address. However ingresses require DNS names, so we will use the nip.io dynamic DNS service for it.

      Using nip.io
      - 10.0.0.1.nip.io resolves to 10.0.0.1
      - similarly 127.0.0.1.nip.io will resolve to 127.0.0.1
      - even wildcard names work: xyz.1.2.3.4.nip.io resolves to 1.2.3.4

      Let's create a dummy ingress now that points to a non-existing app in the cluster, and use the nip.io based DNS name:

      ```
      kubectl create ingress dummy-ingress --rule="nosuchapp.127.0.0.1.nip.io/*=nosuchapp:80"
      ```

      Accessing [http://nosuchapp.127.0.0.1.nip.io](http://nosuchapp.127.0.0.1.nip.io) will return HTTP 404, served by the just deployed Nginx ingress controller. Indicating that the ingress controller works.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#nginx",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled",
            "default": false
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#nginx"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: CertManager
    variable: certManager
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/certManager.png
    description: ""
    onePager: |-
      ### What do you get with Cert Manager?

      Free SSL certificates for all your applications from Let's Encrypt

      ### How to verify the deployment?

      ```
      $ kubectl get pods,clusterissuer --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      cert-manager-cainjector-5c88c48f9-pxc6p                1/1     Running   0          5m2s
      cert-manager-75d94494d6-7zzg4                          1/1     Running   0          5m2s
      cert-manager-webhook-864997b596-jfdpz                  1/1     Running   0          5m2s

      NAME                                        READY   AGE
      clusterissuer.cert-manager.io/letsencrypt   True    1m
      ```

      Once the `ClusterIssuer` is created, Cert Manager is ready to issue Let's Encrypt certificates for your ingresses. It takes about 5 minutes to set it up.

      If you enabled Grafana Loki or Prometheus, then you have already a Kubernetes Ingress that utilizes the certificates:

      ```
      kubectl get ingress -n infrastructure
      NAME      HOSTS                       ADDRESS           PORTS     AGE
      grafana   grafana.test.laszlo.cloud   172.104.145.220   80, 443   13h
      ```

      It binds under the `grafana` subdomain of the host that you set for Nginx, and has the `cert-manager.io/cluster-issuer` annotation that connects the Ingress with the ClusterIssuer,
      indicating that Cert Manager should provision a certificate.

      ```
      kubectl get ingress grafana -n infrastructure

      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        annotations:
          cert-manager.io/cluster-issuer: letsencrypt
          helm.fluxcd.io/antecedent: infrastructure:helmrelease/grafana
          kubernetes.io/ingress.class: nginx
        name: grafana
        namespace: infrastructure
      spec:
        rules:
        - host: grafana.test.laszlo.cloud
          http:
            paths:
            - backend:
                serviceName: grafana
                servicePort: 80
              path: /
        tls:
        - hosts:
          - grafana.test.laszlo.cloud
          secretName: tls-grafana
      ```
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#certManager",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "email": {
                    "$id": "#/properties/email",
                    "type": "string",
                    "title": "Administrator email",
                    "description": "Let's Encrypt will email you on this email upon expiring certificates"
                  }
                },
                "required": [
                  "email"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#certManager"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Loki
    variable: loki
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/loki.png
    description: ""
    onePager: |-
      ### What do you get with Loki?

      - All your logs are forwarded to a dashboard
      - Flexible querying. See applications log realtime, or search for errors across all your apps
      - Log based alerts

      ### How to verify the deployment?
      ```
      $ kubectl get pods --namespace infrastructure

      NAME                         READY   STATUS    RESTARTS   AGE
      grafana-5dc6466b8d-2xkwf     1/1     Running   0          47h
      loki-promtail-bvn87          1/1     Running   0          32m
      loki-0                       1/1     Running   0          32m
      ```

      ### Logging in to Grafana

      Forward the internal ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

      On [http://localhost:8888/explore](http://localhost:8888/explore) start exploring the application logs by selecting the Loki datasource.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled",
            "#/properties/persistence",
            "#/properties/volumeSize"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Grafana Cloud
    variable: grafanaCloud
    category: logging
    logo: https://grafana.com/static/img/menu/grafana2.svg
    description: ""
    onePager: |-
      Install Promtail to ship logs to Grafana Cloud.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#grafanaCloud",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "clusterName": {
            "$id": "#/properties/clusterName",
            "type": "string",
            "title": "Cluster Name",
            "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
          },
          "url": {
            "$id": "#/properties/url",
            "type": "string",
            "title": "URL",
            "description": "URL field on the Grafana Cloud dashboard"
          },
          "username": {
            "$id": "#/properties/username",
            "type": "string",
            "title": "User",
            "description": "User field on the Grafana Cloud dashboard"
          },
          "password": {
            "$id": "#/properties/password",
            "type": "string",
            "title": "Password / API Key",
            "description": "Password field on the Grafana Cloud dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#grafanaCloud"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Event Exporter
    variable: eventExporter
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/opsgenie.png
    description: ""
    onePager: |-
      Install Kubernetes Event Exporter to log all Kubernetes events.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#eventExporter",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#eventExporter"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Prometheus
    variable: prometheus
    category: metrics
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/prometheus.svg
    description: ""
    onePager: |-
      ### What do you get with Prometheus?
      - Infrastructure metrics and dashboards
      - Integration to application metrics
      - Default alerts and dashboards

      ### How to verify the deployment?

      ```
      $ kubectl get pods,svc --namespace infrastructure | grep 'prometheus\|grafana'

      NAME                                                   READY   STATUS    RESTARTS   AGE
      grafana-6987c9c5cf-gsr6x                               1/1     Running   0          66s
      prometheus-kube-state-metrics-c65b87574-qw56j          1/1     Running   0          65s
      prometheus-node-exporter-z8hgt                         1/1     Running   0          65s
      prometheus-pushgateway-7dc7cd5748-zzcc9                1/1     Running   0          65s
      prometheus-alertmanager-78b946d89-8djl8                1/2     Running   0          65s
      prometheus-server-b65c9b875-j62n8                      1/2     Running   0          65s
      service/grafana                               ClusterIP      10.43.64.217    <none>        80/TCP
      service/prometheus-alertmanager               ClusterIP      10.43.154.189   <none>        80/TCP
      service/prometheus-kube-state-metrics         ClusterIP      10.43.66.232    <none>        8080/TCP
      service/prometheus-server                     ClusterIP      10.43.133.254   <none>        80/TCP
      service/prometheus-node-exporter              ClusterIP      None            <none>        9100/TCP
      service/prometheus-pushgateway                ClusterIP      10.43.77.103    <none>        9091/TCP
      ```

      ### Browsing metrics with Grafana
      You can access the dashboards by forwarding the internal Grafana ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#prometheus",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "genericAlerts": {
            "$id": "#/properties/genericAlerts",
            "type": "boolean",
            "title": "Include Alerts",
            "description": "Enable to include generic alerts on CPU / memory / disk usage"
          },
          "retentionDays": {
            "$id": "#/properties/retentionDays",
            "type": "integer",
            "title": "Retentian (in days)",
            "default": 14,
            "minimum": 1,
            "maximum": 365
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1,
            "maximum": 100
          },
          "grafanaCloud": {
            "$id": "#/properties/grafanaCloud",
            "type": "object",
            "title": "Write to Grafana Cloud",
            "properties": {
              "enabled": {
                "$id": "#/properties/enabled",
                "type": "boolean",
                "title": "Enabled"
              },
              "clusterName": {
                "$id": "#/properties/clusterName",
                "type": "string",
                "title": "Cluster Name",
                "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
              },
              "url": {
                "$id": "#/properties/url",
                "type": "string",
                "title": "Remote Write Endpoint",
                "description": "Remote Write Endpoint URL on the Grafana Cloud dashboard"
              },
              "username": {
                "$id": "#/properties/username",
                "type": "string",
                "title": "Username / Instance ID",
                "description": "Username / Instance ID on the Grafana Cloud dashboard"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Password / API Key",
                "description": "Password / API Key on the Grafana Cloud dashboard"
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#prometheus"
          ],
          "uiSchema": {
            "#/properties/retentionDays": {
              "ui:widget": "range"
            },
            "#/properties/volumeSize": {
              "ui:widget": "range"
            }
          },
          "metaData": {}
        }
      ]
  - name: Sealed Secrets
    variable: sealedSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/sealedSecrets.svg
    description: ""
    onePager: |-
      ### What do you get with Sealed Secrets?
      - A secret manager that allows a simple secret workflow for gitops repositories.
      - Uses asymmetric cryptography to encrypt secrets, just like HTTPS.
      ### How to verify the deployment?

      ```
      $ kubectl get pods --namespace infrastructure

      NAME                              READY   STATUS    RESTARTS   AGE
      sealed-secrets-7d7cc48f7f-q64sm   1/1     Running   0          14m
      ```

      Once the pod is running, secrets will be unsealed inside the cluster and made available for your applications.

      ### After verification

      In order to encrypt secrets, run the following steps:

      #### Install the `kubeseal` utility

      You will use this utility to encrypt secrets for your applications. It uses asymmetric crypto to encrypt secrets that only the controller can decrypt.

      Mac:
      ```
      brew install kubeseal
      ```

      Linux:
      ```
      wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.12.6/kubeseal-linux-amd64 -O kubeseal
      sudo install -m 755 kubeseal /usr/local/bin/kubeseal
      ```

      #### Important steps after installing Sealed Secrets

      Perform these steps if you install Sealed Secrets for the first time, and you don't have encrypted secrets in your gitops repo yet.

      - fetch the sealing key

      ```
      kubeseal --fetch-cert --controller-namespace=infrastructure > sealing-key.pub
      ```

      This key is used to encrypt your secrets. It is only used to encrypt the secrets, noone can decrypt the secrets with this key, so you can share it with anyone.

      It is recommended that you add this key as a "Sealing Public Key" to 1-Click Infra bellow, so all keys in the gitops repo will be encrypted.

      - backup the master key

      ```
      kubectl get secret -n infrastructure -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml > master.key
      ```

      Keep this key secret, as this is the only key that can decrypt the secrets.
      Use it only in case of a cluster restoration.

      **Steps after restoration**

      Perform these steps if you are restoring your cluster, and you have encrypted secrets in your gitops repo already.

      Locate your backed up master key and apply it on the cluster.

      ```
      kubectl apply -f master.key
      ```

      Then restart the Sealed Secrets to pick up the master key:

      ```
      kubectl -n infrastructure delete pod -l name=sealed-secrets-controller
      ```

      Now your cluster can decrypt all secrets from the gitops repo.

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: ExternalSecrets
    variable: externalSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/external-secrets/external-secrets/main/assets/eso-logo-medium.png
    description: ""
    onePager: |-
      The project extends the Kubernetes API by adding an ExternalSecrets object using Custom Resource Definition and a controller to implement the behavior of the object itself.

      An ExternalSecret declares how to fetch the secret data, while the controller converts all ExternalSecrets to Secrets. The conversion is completely transparent to Pods that can access Secrets normally.

      - `ExternalSecrets` are added in the cluster (e.g., kubectl apply -f external-secret-example.yml)
      - Controller fetches `ExternalSecrets` using the Kubernetes API
      - Controller uses `ExternalSecrets` to fetch secret data from external providers (e.g, AWS Secrets Manager)
      - Controller upserts `Secrets`
      - Pods can access `Secrets` normally
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: OAuth2Proxy
    variable: oauth2Proxy
    category: ingress
    logo: https://raw.githubusercontent.com/oauth2-proxy/oauth2-proxy/master/docs/static/img/logos/OAuth2_Proxy_icon.svg
    description: ""
    onePager: |-
      ### What do you get with OAuth2Proxy?
      - You can authenticate your internal services with Github
      - Use it instead of a VPN

      ### How to verify the deployment?

      ```
      kubectl get pods --namespace infrastructure
      ```
      ```
      NAME                                                   READY   STATUS    RESTARTS   AGE
      oauth2-proxy-56cc5665c5-t6472                          2/2     Running   2          18h
      ```

      ### Configuring the Github OAuth app

      Follow the [Github guide](https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app).

      - Set `https://auth.<<your-nginx-domain>>` for "Homepage URL"
      - Set `https://auth.<<your-nginx-domain>>/oauth2/callback` for "Authorization callback URL"

      ### Add OAuth to your service
      To add authentication for your services, add the following annotations to your ingresses:
      ```diff
      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        name: my-app
        namespace: infrastructure
        annotations:
          kubernetes.io/ingress.class: 'nginx'
      +   nginx.ingress.kubernetes.io/auth-url: "https://auth.<<your-nginx-domain>>/oauth2/auth"
      +   nginx.ingress.kubernetes.io/auth-signin: "https://auth.<<your-nginx-domain>>/oauth2/start?rd=/redirect/$http_host$escaped_request_uri"
      spec:
        tls:
        - hosts:
          - my-app.<<your-nginx-domain>>
        rules:
          - host: my-app.<<your-nginx-domain>>
            http:
              paths:
                - backend:
                    serviceName: my-app
                    servicePort: 80
      ```

      ### Checking if you are logged in

      Visit [https://auth.<<your-nginx-domain>>/oauth2/userinfo](https://auth.<<your-nginx-domain>>/oauth2/userinfo)
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#oauth2Proxy",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "cookieSecret": {
            "$id": "#/properties/cookieSecret",
            "type": "string",
            "title": "Cookie Secret",
            "description": "A random seed string that is the base of cookie encryption. eg: the output of `openssl rand -hex 16`"
          },
          "org": {
            "$id": "#/properties/org",
            "type": "string",
            "title": "Github Organization",
            "description": "Github users member of this organization will be allowed to access your protected sites"
          },
          "user": {
            "$id": "#/properties/user",
            "type": "string",
            "title": "Github User",
            "description": "If you want to grant access per user basis, a comma separated list"
          },
          "clientID": {
            "$id": "#/properties/clientID",
            "type": "string",
            "title": "Github ClientID",
            "description": "ClientID of the Github OAuth application"
          },
          "clientSecret": {
            "$id": "#/properties/clientSecret",
            "type": "string",
            "title": "Github Client Secret",
            "description": "Client secret of the Github OAuth application"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#oauth2Proxy"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet
    variable: gimlet
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ""
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimlet",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "host": {
            "$id": "#/properties/host",
            "type": "string",
            "title": "Host name",
            "description": "The hostname the dashboard is accessible on. Together with the protocol eg.: https://gimlet.mycompany.com"
          },
          "jwtSecret": {
            "$id": "#/properties/jwtSecret",
            "type": "string",
            "title": "JWT Secret",
            "description": "Random string to seed JWT tokens, eg the output of `openssl rand -hex 32`"
          },
          "githubOrg": {
            "$id": "#/properties/githubOrg",
            "type": "string",
            "title": "Github Organization",
            "description": "Users that are members of this Github Organization will be able to authenticate to the dashboard"
          },
          "githubAppId": {
            "$id": "#/properties/githubAppId",
            "type": "string",
            "title": "Github App ID",
            "description": ""
          },
          "githubPrivateKey": {
            "$id": "#/properties/githubPrivateKey",
            "type": "string",
            "title": "Github Private Key",
            "description": ""
          },
          "githubClientId": {
            "$id": "#/properties/githubClientId",
            "type": "string",
            "title": "Github Client ID",
            "description": ""
          },
          "githubClientSecret": {
            "$id": "#/properties/githubClientSecret",
            "type": "string",
            "title": "Github Client Secret",
            "description": ""
          },
          "webhookSecret": {
            "$id": "#/properties/webhookSecret",
            "type": "string",
            "title": "Webhook Secret",
            "description": ""
          },
          "postgresql": {
            "$id": "#/properties/postgresql",
            "type": "object",
            "title": "Postgresql settings",
            "description": "",
            "properties": {
              "install": {
                "$id": "#/properties/install",
                "type": "boolean",
                "title": "Install Postgresql",
                "description": "Install a Postgresql instance to host Gimlet data"
              },
              "postgresPassword": {
                "$id": "#/properties/postgresPassword",
                "type": "string",
                "title": "Postgresql Admin Password",
                "description": "Fill it if you install Postgresql together with Gimlet"
              },
              "hostAndPort": {
                "$id": "#/properties/hostAndPort",
                "type": "string",
                "title": "Postgresql Host and Port",
                "description": "If you install a postgresql together with Gimlet, then it is `postgres:5432`",
                "default": "postgres:5432"
              },
              "db": {
                "$id": "#/properties/database",
                "type": "string",
                "title": "Postgresql Database Name",
                "default": "gimlet_dasboard"
              },
              "user": {
                "$id": "#/properties/user",
                "type": "string",
                "title": "Postgresql User",
                "description": "",
                "default": "gimlet_dashboard"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Postgresql Password",
                "description": ""
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimlet"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet Agent
    variable: gimletAgent
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ""
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimletAgent",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "environment": {
            "$id": "#/properties/environment",
            "type": "string",
            "title": "Environment",
            "description": "The logical name of the environment the agent is deployed to"
          },
          "dashboardAddress": {
            "$id": "#/properties/dashboardAddress",
            "type": "string",
            "title": "Gimlet Dashboard Address",
            "description": "The address where Gimlet Dashboard is running, eg.: https://gimlet.mycompany.com"
          },
          "agentKey": {
            "$id": "#/properties/agentKey",
            "type": "string",
            "title": "Agent Key",
            "description": "Agent Key to authenticate to Gimlet Dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimletAgent"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Image Builder
    variable: imageBuilder
    category: gimlet
    logo: https://cncf-branding.netlify.app/img/projects/buildpacks/icon/black/buildpacks-icon-black.png
    description: ""
    onePager: "Image builder is a simple web server application that handles file uploads and builds images from it."

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#imageBuilder",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#imageBuilder"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Namespaces
    variable: namespaces
    category: system
    logo: "https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/system.svg"
    description: ""
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "namespaces",
        "type": "object",
        "default": {},
        "properties": {
          "namespaces": {
            "$id": "#/properties/namespaces",
            "type": "array",
            "title": "Namespaces",
            "default": [],
            "additionalItems": true,
            "items": {
              "$id": "#/properties/namespaces/items",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "$id": "#/properties/namespaces/items/properties/name",
                  "type": "string",
                  "title": "Namespace"
                }
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "namespaces"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: KEDA
    variable: keda
    category: autoscaling
    logo: https://keda.sh/img/logos/keda-horizontal-color.png
    description: ""
    onePager: "KEDA is an alternative solution for Prometheus Adapter, it gives you a simple, straightforward and efficient approach to autoscale your application."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#keda",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#keda"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Docker Registry
    variable: dockerRegistry
    category: registry
    logo: https://d1q6f0aelx0por.cloudfront.net/product-logos/library-registry-logo.png
    description: ""
    onePager: "Docker registry is a storage and distribution system for named Docker images."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#dockerRegistry",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#dockerRegistry"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
changeLog: |
  - ü¶ã Upgraded all stack components to latest version possible!
  - üçè External Secrets upgraded to v0.9.11
  - üçè Grafana upgraded to 10.3.1
  - üçè Upgraded onechart to 0.65.0 for Image Builder
  - üçè Ingres Nginx upgraded to 1.9.6
  - üçè Keda upgraded to 2.13.0
  - üçè Prometheus Node Exporter upgraded to 1.7.0
  - üçè Prometheus upgraded to v2.49.1
  - üçè Promtail upgraded to 2.9.3
  - üçè Sealed Secrets upgraded to 0.25.0 v1.13.3
  - üçè Cert Manager upgraded to v1.13.3

message: |

  Hey üëã Laszlo here, the founder of Gimlet.io

  Thank you for using Gimlet!

  Our goal is to help you

  - to get started with your Kubernetes stack
  - to navigate new versions
  - and to give you best practices

  Now that you generated Kubernetes resources from your stack, 
  maybe you are interested in how to manage it in the future

  üëâ https://gimlet.io/docs/managing-infrastructure-components

  Onwards!
